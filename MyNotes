N- Chapter1 , page 15 
Table 1-4 Symbol Commands :
( )       Runs the enclosed command in a sub-shell
  As an example :
  $ pwd 
  $ /home/user1
  $ ( cd Documents ; pwd )
  $ /home/user1/Documents
  $ pwd
  $ /home/user1

E- Chapter1 , page 15 
Command-Line Arguments :
    "The positional parameters, $0, $2, and so on in a function are for the function’s use" 
The correct text should be 
    "The positional parameters, $1, $2, and so on in a function are for the function’s use"

E- Chapter1 , page 16-17
Listing 1-2 Example of using the shift command
The script (it is a kind of template ,but still it should be clear) as it is written in the book,
does not provide a mechanism to exit the while-loop. And the point at which the addition +1 happens 
isnot good. Here is how it should be :
  #!/usr/bin/sh
  # Mastering Unix Shell scripting 2008, Chapter1 page 16
  # Listing 1-2 Example of using the shift command
  TOTAL=0		# Initialize the TOTAL counter to zero
  # Start a while loop
  while true
  do
  	TOKEN=$1
  	[ -z $TOKEN ] && break;  #if no command line argument was given break out of while-loop
  	TOTAL=`expr $TOTAL + 1`  #or TOTAL=$(($TOTAL + 1))
  	echo "Argument processed : $TOKEN " #
  	shift		# Grab the next token, i.e. $2 becomes $1
  done
  echo "Total number of tokens processed: $TOTAL"

N- Chapter1 Setting traps , page 25
One full example can be:
  #!/bin/bash
  echo "we create a temporary file in /tmp"
  touch /tmp/trap_file.txt
  trap 'echo -e "\nPremature termination.Cleaning temp files before exiting.\n"; rm /tmp/temp_file.txt; exit' 1 2 3 15
  read -p "give some words as input to the file /tmp/trap_file.txt: "
  echo $REPLY > /tmp/trap_file.txt
  echo "Here are the contents of the file , before we destroy it:"
  cat /tmp/trap_file.txt
  rm /tmp/trap_file.txt

E- Chapter1 Output Control , page 32 Silent running
The book has an example of :
  /PATH/script_name 2>&1 > /dev/null
to redirect the error stream file descriptor 2 at the same stream as the stdout file descriptor 1
and then supposedly both of them will be redirected in the /dev/null , so no output to clutter the console.
But at least in bash , the correct is:
  /PATH/script_name  1> /dev/null 2>&1
so first the redirection of fd 1 must go to /dev/null (or any other file, to really check it)
and then the fd 2 follows where ever &1 is redirected.  
This can easily be tested with something that produces both an error message and a normal output message.
   ls nonexistentfile existingfile 1> ls_results 2>&1
where existing file must exist. This way the contents of ls_results file will have both the error (for nonexistentfile)
and the normal output (for existingfile). I tested it for both bash and ksh.

E- Chapter1 Using getops to parse command-line arguments ,page 34 
Here is a more complete example with corrections
  #!/bin/bash
  SECS=0		# Initialize all to zero
  MINUTES=0
  HOURS=0 
  TOTAL_SECONDS=0  #This is missing from the book, but it is crusial for the final calculation
  PROCESS=	# Initialize to null , empty string
  usage () { 
  	echo "$(basename $0) -s S -m M -h H ";echo "Where S is integer number for seconds,M for minutes,H for hours";
  }   #The book does not provide some implementation of the function usage
  while getopts :s:m:h:d:p: TIMEOPT 2>/dev/null
  do
  	case $TIMEOPT in
		  s) SECS=$OPTARG ;;
		  m) (( MINUTES = $OPTARG * 60 )) ;;
		  h) (( HOURS = $OPTARG * 3600 ))	;;
		  d) (( DAYS = $OPTARG * 86400 )) ;;
		  p) PROCESS=$OPTARG ;;
		  \?) usage ; exit 1 ;;
	  esac
  done
  (( TOTAL_SECONDS = $SECS + $MINUTES + $HOURS + $DAYS )) #Here the book has wrong name SECONDS ,and also forgets the $
  echo "We will monitor the application $PROCESS for $TOTAL_SECONDS seconds"
